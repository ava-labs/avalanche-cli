// Copyright (C) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.
package cubist

import (
	"encoding/hex"
	"fmt"
	"github.com/ava-labs/avalanche-cli/pkg/cobrautils"
	"github.com/ava-labs/avalanchego/utils/crypto/secp256k1"
	"github.com/ava-labs/avalanchego/vms/components/verify"
	"github.com/ava-labs/avalanchego/vms/platformvm/txs"
	"github.com/ava-labs/avalanchego/vms/secp256k1fx"
	"github.com/spf13/cobra"
	"log"
)

func callTest(_ *cobra.Command, args []string) error {
	unsignedTxHex := "0x0000000000050000000000000000000000000000000000000000000000000000000000000000000000013d9bdac0ed1d761330cf680efdeb1a42159eb387d6d2950c96f7d28f61bbe2aa00000007000000012a05c9da00000000000000000000000100000001e1cb189190da68dd6016dc408cb85f08fd0ee22c0000000156c6eb6f01d779a7aa497a302aaa68ceabd8e0c5bef8ee4d66b281b018062eeb000000003d9bdac0ed1d761330cf680efdeb1a42159eb387d6d2950c96f7d28f61bbe2aa00000005000000012a05f2000000000100000000000000000000000b00000000000000000000000100000001e1cb189190da68dd6016dc408cb85f08fd0ee22c04501e4b"
	signatureHex := "0x0aa44f3d42b73121a4dd9e5b0b57a5d6d1009d05bfd4c31eaf82f06e5358642c593ecca76ecdb6658b89548fc560ac0c5157afce1517ba05f2198b2d6fcfa5ab01"

	fmt.Println("=== Creating Signed Transaction ===")

	// Decode unsigned transaction
	if unsignedTxHex[:2] == "0x" {
		unsignedTxHex = unsignedTxHex[2:]
	}

	unsignedTxBytes, err := hex.DecodeString(unsignedTxHex)
	if err != nil {
		log.Fatalf("Failed to decode unsigned transaction: %v", err)
	}

	// Parse the unsigned transaction
	var createSubnetTx txs.CreateSubnetTx
	if _, err := txs.Codec.Unmarshal(unsignedTxBytes, &createSubnetTx); err != nil {
		log.Fatalf("Failed to unmarshal unsigned transaction: %v", err)
	}

	fmt.Printf("✅ Successfully parsed CreateSubnetTx\n")
	fmt.Printf("Network ID: %d\n", createSubnetTx.NetworkID)
	fmt.Printf("Number of inputs: %d\n", len(createSubnetTx.Ins))
	fmt.Printf("Number of outputs: %d\n", len(createSubnetTx.Outs))

	// Decode signature
	if signatureHex[:2] == "0x" {
		signatureHex = signatureHex[2:]
	}

	signatureBytes, err := hex.DecodeString(signatureHex)
	if err != nil {
		log.Fatalf("Failed to decode signature: %v", err)
	}

	fmt.Printf("Signature length: %d bytes\n", len(signatureBytes))

	// Convert to fixed-size signature array
	var sig [secp256k1.SignatureLen]byte
	copy(sig[:], signatureBytes)

	// Create signed transaction
	signedTx := &txs.Tx{
		Unsigned: &createSubnetTx,
		Creds: []verify.Verifiable{
			&secp256k1fx.Credential{
				Sigs: [][secp256k1.SignatureLen]byte{
					sig,
				},
			},
		},
	}

	// Initialize
	if err := signedTx.Initialize(txs.Codec); err != nil {
		log.Fatalf("Failed to initialize transaction: %v", err)
	}

	fmt.Printf("Transaction ID: %s\n", signedTx.ID())

	// Test parsing
	signedTxBytes := signedTx.Bytes()
	fmt.Printf("Signed transaction bytes length: %d\n", len(signedTxBytes))

	parsedTx, err := txs.Parse(txs.Codec, signedTxBytes)
	if err != nil {
		log.Fatalf("Failed to parse signed transaction: %v", err)
	}

	fmt.Printf("✅ Successfully parsed signed transaction: %s\n", parsedTx.ID())

	fmt.Println("\n=== Ready to Issue Transaction ===")
	fmt.Println("The transaction is ready to be issued to the network.")
	fmt.Println("Uncomment the code below to actually issue it:")
	return nil
}

func newTestCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "test",
		Short: "Create a signing key",
		Long: `The key create command generates a new private key to use for creating and controlling
test Subnets. Keys generated by this command are NOT cryptographically secure enough to
use in production environments. DO NOT use these keys on Mainnet.

The command works by generating a secp256 key and storing it with the provided keyName. You
can use this key in other commands by providing this keyName.

If you'd like to import an existing key instead of generating one from scratch, provide the
--file flag.`,
		Args: cobrautils.ExactArgs(0),
		RunE: callTest,
	}

	return cmd
}
